import cupy as cp
import chainer.functions as F


def gradient_loss(generated, truth):
	"""

	:param generated: generated image by the generator at any scale
	:param truth: The ground truth image at that scale
	:return: GDL loss
	"""
	xp = cp.get_array_module(generated.data)
	n, c, h, w = generated.shape
	# wx = xp.array([[[-1, 1, -1]]]*c, ndmin=4).astype(xp.float32)
	# wy = xp.array([[[-1], [1], [-1]]]*c, ndmin=4).astype(xp.float32)
	w_left2bottom = xp.array([[[-1, 0, 0],
							   [0, 1, 0],
							  [0, 0, -1]]]*c, ndmin=4).astype(xp.float32)
	# w_right2bottom = xp.array([[[0, 0, -1],
	# 						   [0, 1, 0],
	# 						  [-1, 0, 0]]]*c, ndmin=4).astype(xp.float32)

	# d_gx = F.convolution_2d(generated, wx)
	# d_gy = F.convolution_2d(generated, wy)
	d_g_left2bottom = F.convolution_2d(generated, w_left2bottom)
	# d_g_right2bottom = F.convolution_2d(generated, w_right2bottom)

	# d_tx = F.convolution_2d(truth, wx)
	# d_ty = F.convolution_2d(truth, wy)
	d_t_left2bottom = F.convolution_2d(truth, w_left2bottom)
	# d_t_right2bottom = F.convolution_2d(truth, w_right2bottom)

	# return (F.sum(F.absolute(d_gx - d_tx)) + F.sum(F.absolute(d_gy - d_ty))
	#  		+ F.sum(F.absolute(d_g_left2bottom - d_t_left2bottom)) + F.sum(F.absolute(d_g_right2bottom - d_t_right2bottom)))
	# return (F.sum(F.absolute(d_gx - d_tx)) + F.sum(F.absolute(d_gy - d_ty)))
	# return (F.sum(F.absolute(d_g_left2bottom - d_t_left2bottom)) + F.sum(F.absolute(d_g_right2bottom - d_t_right2bottom)))
	return F.sum(F.absolute(d_g_left2bottom - d_t_left2bottom))


def l2_loss(generated, truth):
	"""
	:param generated: Image generated by the Generator at any scale
	:param truth: Corresponding ground truth image
	:return: L2 Loss between the images
	"""
	n, c, h, w = generated.shape
	return (F.sum(F.squared_difference(generated, truth)))

def huber_loss(generated, truth):
	n, c, h, w = generated.shape
	return (F.sum(F.huber_loss(generated, truth, delta=0.5)))

def l1_loss(generated, truth):
	n, c, h, w = generated.shape
	# return (F.sum(F.absolute_error(generated, truth)))
	return (F.sum(F.mean_absolute_error(generated, truth)))


def loss_target1(dis_output):
	"""

	:param dis_output: Output of the disciminator, ie the probablilites
	:return: Error when the targets are 1s
	"""
	n, _ = dis_output.shape
	return -F.sum(F.log(dis_output))
	# WGAN-GP
	# return -F.sum(dis_output)


def loss_target0(dis_output):
	"""

	:param dis_output: Output of the disciminator, ie the probablilites
	:return: Error when the targets are 0s
	"""
	n, _ = dis_output.shape
	return -F.sum(F.log(1 - dis_output))
	# WGAN-GP
	# return -F.sum(1 - dis_output)

# TODO: PSNR LOSS